<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Range-v3: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Range-v3
   </div>
   <div id="projectbrief">Range algorithms, views, and actions for the Standard Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a><ul><li class="level2"><a href="#tutorial-installation">Installation</a></li>
<li class="level2"><a href="#tutorial-license">License</a></li>
<li class="level2"><a href="#tutorial-compilers">Supported Compilers</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-quick-start">Quick Start</a></li>
<li class="level1"><a href="#range-views">Range Views</a></li>
<li class="level1"><a href="#tutorial-examples">Examples</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> Range library for C++11/14/17. This code is the basis of <a href="https://ericniebler.github.io/std/wg21/D4128.html">a formal proposal</a> to add range support to the C++ standard library.</p>
<p><b>Development Status:</b></p>
<p>This code is fairly stable, well-tested, and suitable for casual use, although currently lacking documentation. No promise is made about support or long-term stability. This code <em>will</em> evolve without regard to backwards compatibility.</p>
<h2><a class="anchor" id="tutorial-installation"></a>
Installation</h2>
<hr/>
<p> This library is header-only. You can get the source code from the <a href="https://github.com/ericniebler/range-v3">range-v3 repository</a> on github. To compile with Range-v3, you can either <code>#include</code> the entire library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div>
</div><!-- fragment --><p>Or you can <code>#include</code> only the core, and then the individual headers you want:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_8hpp.html">range/v3/core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;range/v3/....</span></div>
</div><!-- fragment --><h2><a class="anchor" id="tutorial-license"></a>
License</h2>
<hr/>
<p> Most of the source code in this project are mine, and those are under the Boost Software License. Parts are taken from Alex Stepanov's Elements of Programming, Howard Hinnant's libc++, and from the SGI STL. Please see the attached LICENSE file and the CREDITS file for the licensing and acknowledgements.</p>
<h2><a class="anchor" id="tutorial-compilers"></a>
Supported Compilers</h2>
<hr/>
<p> The code is known to work on the following compilers:</p>
<ul>
<li>clang 3.4.0</li>
<li>GCC 4.9.0</li>
</ul>
<h1><a class="anchor" id="tutorial-quick-start"></a>
Quick Start</h1>
<hr/>
<p> Range v3 is a generic library that augments the existing standard library with facilities for working with <em>ranges</em>. A range can be loosely thought of a pair of iterators, although they need not be implemented that way. Bundling begin/end iterators into a single object brings several benefits.</p>
<h2>Why Use Ranges?</h2>
<h3>Convenience</h3>
<p>It's more convenient to pass a single range object to an algorithm than separate begin/end iterators. Compare:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v{<span class="comment">/*...*/</span>};</div>
<div class="line"><a class="code" href="group__transformation.html#gacb0ffa1c28bd04a71adae30dc02ac000">std::sort</a>( v.begin(), v.end() );</div>
</div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v{<span class="comment">/*...*/</span>};</div>
<div class="line"><a class="code" href="group__transformation.html#gacb0ffa1c28bd04a71adae30dc02ac000">ranges::sort</a>( v );</div>
</div><!-- fragment --><p>Range v3 contains a full implementation of all the standard algorithms with range-based overloads for convenience.</p>
<h3>Composability</h3>
<p>Having a single range object permits <em>pipelines</em> of operations. In a pipeline, a range is lazily adapted or eagerly mutated in some way, with the result immediately available for further adaptation or mutation. Lazy adaption is handled by <em>views</em>, and eager mutation is handled by <em>actions</em>.</p>
<h4>Views</h4>
<p>A view is a lightweight wrapper that presents a view of an underlying sequence of elements in some custom way without mutating or copying it. Views are cheap to create and copy, and have non-owning reference semantics. Below are some examples:</p>
<p>Filter a container using a predicate and transform it.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vi{1,2,3,4,5,6,7,8,9,10};</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line"><span class="keyword">auto</span> rng = vi | view::remove_if([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i % 2 == 1;})</div>
<div class="line">              | <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> std::to_string(i);});</div>
<div class="line"><span class="comment">// rng == {&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;};</span></div>
</div><!-- fragment --><p>Generate an infinite list of integers starting at 1, square them, take the first 10, and sum them:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line"><span class="keywordtype">int</span> sum = <a class="code" href="group__transformation.html#ga8eabba98e40ae21a7434a339896ae1c0">accumulate</a>(view::ints(1)</div>
<div class="line">                   | <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i*i;})</div>
<div class="line">                   | view::take(10), 0);</div>
</div><!-- fragment --><p>Generate a sequence on the fly with a range comprehension and initialize a vector with it:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line">std::vector&lt;int&gt; vi =</div>
<div class="line">    <a class="code" href="group__runtime.html#ga4d1b825778809ff9c5f20c84d7f06a0f">view::for_each</a>(view::ints(1,10), [](<span class="keywordtype">int</span> i){</div>
<div class="line">        <span class="keywordflow">return</span> yield_from(view::repeat(i,i));</div>
<div class="line">    });</div>
<div class="line"><span class="comment">// vi == {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...}</span></div>
</div><!-- fragment --><h4>Actions</h4>
<p>When you want to mutate a container in-place, or forward it through a chain of mutating operations, you can use actions. The following examples should make it clear.</p>
<p>Read data into a vector, sort it, and make it unique.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> std::vector&lt;int&gt; read_data();</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line">std::vector&lt;int&gt; vi = read_data() | <a class="code" href="group__transformation.html#gacb0ffa1c28bd04a71adae30dc02ac000">action::sort</a> | <a class="code" href="group__transformation.html#gad96613af2fa2b8b09f7ba5c907cdd62d">action::unique</a>;</div>
</div><!-- fragment --><p>Do the same to a <code>vector</code> that already contains some data:</p>
<div class="fragment"><div class="line">vi = std::move(vi) | <a class="code" href="group__transformation.html#gacb0ffa1c28bd04a71adae30dc02ac000">action::sort</a> | <a class="code" href="group__transformation.html#gad96613af2fa2b8b09f7ba5c907cdd62d">action::unique</a>;</div>
</div><!-- fragment --><p>Mutate the container in-place:</p>
<div class="fragment"><div class="line">vi |= <a class="code" href="group__transformation.html#gacb0ffa1c28bd04a71adae30dc02ac000">action::sort</a> | <a class="code" href="group__transformation.html#gad96613af2fa2b8b09f7ba5c907cdd62d">action::unique</a>;</div>
</div><!-- fragment --><p>Same as above, but with function-call syntax instead of pipe syntax:</p>
<div class="fragment"><div class="line"><a class="code" href="group__transformation.html#gad96613af2fa2b8b09f7ba5c907cdd62d">action::unique</a>(<a class="code" href="group__transformation.html#gacb0ffa1c28bd04a71adae30dc02ac000">action::sort</a>(vi));</div>
</div><!-- fragment --><h2>Create Custom Ranges</h2>
<p>Range v3 provides a utility for easily creating your own range types, called <code>range_facade</code>. The code below uses <code>range_facade</code> to create a range that traverses a null-terminated string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// A range that iterates over all the characters in a</span></div>
<div class="line"><span class="comment">// null-terminated string.</span></div>
<div class="line"><span class="keyword">class </span>c_string_range</div>
<div class="line">  : <span class="keyword">public</span> range_facade&lt;c_string_range&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">friend</span> range_access;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> * sz_;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> &amp; current()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *sz_; }</div>
<div class="line">    <span class="keywordtype">bool</span> done()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *sz_ == <span class="charliteral">&#39;\0&#39;</span>; }</div>
<div class="line">    <span class="keywordtype">void</span> next() { ++sz_; }</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    c_string_range() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">explicit</span> c_string_range(<span class="keywordtype">char</span> <span class="keyword">const</span> *sz) : sz_(sz)</div>
<div class="line">    {</div>
<div class="line">        assert(sz != <span class="keyword">nullptr</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>range_facade</code> class generates an iterator and begin/end member functions from the minimal interface provided by <code>c_string_range</code>. This is an example of a very simple range for which it is not necessary to separate the range itself from the thing that iterates the range. Future examples will show examples of more sophisticated ranges.</p>
<p>With <code>c_string_range</code>, you can now use algorithms to operate on null-terminated strings, as below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    c_string_range r(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line">    <span class="comment">// Iterate over all the characters and print them out</span></div>
<div class="line">    <a class="code" href="group__runtime.html#ga4d1b825778809ff9c5f20c84d7f06a0f">ranges::for_each</a>(r, [](<span class="keywordtype">char</span> ch){</div>
<div class="line">        std::cout &lt;&lt; ch &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    });</div>
<div class="line">    <span class="comment">// prints: h e l l o   w o r l d</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Adapting Ranges</h2>
<p>Often, a new range type is most easily expressed by adapting an existing range type. That's the case for many of the range views provided by the Range v3 library; for example, the <code>view::remove_if</code> and <code>view::transform</code> views. These are rich types with many moving parts, but thanks to a helper class called <code>range_adaptor</code>, they aren't hard to write.</p>
<p>Below in roughly 2 dozen lines of code is the <code>transform</code> view, which takes one range and transforms all the elements with a unary function.</p>
<div class="fragment"><div class="line"><span class="comment">// A class that adapts an existing range with a function</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng, <span class="keyword">class</span> Fun&gt;</div>
<div class="line"><span class="keyword">class </span>transform_view : <span class="keyword">public</span> range_adaptor&lt;transform_view&lt;Rng, Fun&gt;, Rng&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">friend</span> range_access;</div>
<div class="line">    semiregular_t&lt;Fun&gt; fun_; <span class="comment">// Make Fun model SemiRegular if it doesn&#39;t</span></div>
<div class="line">    <span class="keyword">class </span>adaptor : <span class="keyword">public</span> adaptor_base</div>
<div class="line">    {</div>
<div class="line">        semiregular_t&lt;Fun&gt; fun_;</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        adaptor() = <span class="keywordflow">default</span>;</div>
<div class="line">        adaptor(semiregular_t&lt;Fun&gt; <span class="keyword">const</span> &amp;fun) : fun_(fun) {}</div>
<div class="line">        <span class="comment">// Here is where we apply Fun to the elements:</span></div>
<div class="line">        <span class="keyword">auto</span> current(range_iterator_t&lt;Rng&gt; it) <span class="keyword">const</span> -&gt; decltype(fun_(*it))</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> fun_(*it);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    adaptor begin_adaptor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {fun_}; }</div>
<div class="line">    adaptor end_adaptor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {fun_}; }</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    transform_view() = <span class="keywordflow">default</span>;</div>
<div class="line">    transform_view(Rng &amp;&amp; rng, Fun fun)</div>
<div class="line">      : range_adaptor_t&lt;transform_view&gt;{std::forward&lt;Rng&gt;(rng)}</div>
<div class="line">      , fun_(std::move(fun))</div>
<div class="line">    {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng, <span class="keyword">class</span> Fun&gt;</div>
<div class="line">transform_view&lt;Rng, Fun&gt; <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">transform</a>(Rng &amp;&amp; rng, Fun fun)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> {std::forward&lt;Rng&gt;(rng), std::move(fun)};</div>
<div class="line">}</div>
</div><!-- fragment --><p>Range transformation is achieved by defining a nested <code>adaptor</code> class that handles the transformation, and then defining <code>begin_adaptor</code> and <code>end_adaptor</code> members that return adaptors for the begin iterator and the end sentinel, respectively. The <code>adaptor</code> class has a <code>current</code> member that performs the transformation. It is passed an iterator to the current element. Other members are available for customization: <code>equal</code>, <code>next</code>, <code>prev</code>, <code>advance</code>, and <code>distance_to</code>; but the transform adaptor accepts the defaults defined in <code>adaptor_base</code>.</p>
<p>With <code>transform_view</code>, we can print out the first 20 squares:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> squares = <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">::transform</a>(view::ints(1), [](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i*i;});</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : squares | view::take(20))</div>
<div class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    <span class="comment">// prints 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>transform_view</code> defined above is an InputRange when its wrapping an InputRange, a ForwardRange when its wrapping a ForwardRange, etc. That happens because of smart defaults defined in the <code>adaptor_base</code> class. That frees you from having to deal with a host of niggly detail when implementing iterators.</p>
<p>*(Note: the above <code>transform_view</code> always stores a copy of the function in the sentinel. That is only necessary if the underlying range's sentinel type models BidirectionalIterator. That's a finer point that you shouldn't worry about right now.)*</p>
<h2>Constrain Functions with Concepts</h2>
<p>The Range v3 library makes heavy use of concepts to constrain functions, control overloading, and check type constraints at compile-time. It achieves this with the help of a Concepts Lite emulation layer that works on any standard-conforming C++11 compiler. The library provides many useful concepts, both for the core language and for iterators and ranges. You can use the concepts framework to constrain your own code.</p>
<p>For instance, if you would like to write a function that takes an iterator/sentinel pair, you can write it like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class </span>Iter, <span class="keyword">class </span>Sent, <span class="keyword">class </span>Comp = <span class="comment">/*...some_default..*/</span>,</div>
<div class="line">    CONCEPT_REQUIRES_(IteratorRange&lt;Iter, Sent&gt;())&gt;</div>
<div class="line"><span class="keywordtype">void</span> my_algorithm(Iter <a class="code" href="group__list.html#ga9447487bb1ccdc8867d000c98f992e91">first</a>, Sent last, Comp comp = Comp{})</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>You can then add an overload that take a Range:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class </span>Rng, <span class="keyword">class </span>Comp = <span class="comment">/*...some_default..*/</span>,</div>
<div class="line">    CONCEPT_REQUIRES_(Range&lt;Rng&gt;())&gt;</div>
<div class="line"><span class="keywordtype">void</span> my_algorithm(Rng &amp;&amp; rng, Comp comp = Comp{})</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> my_algorithm(ranges::begin(rng), ranges::end(rng));</div>
<div class="line">}</div>
</div><!-- fragment --><p>With the type constraints expressed with the <code>CONCEPTS_REQUIRES_</code> macro, these two overloads are guaranteed to not be ambiguous.</p>
<h2>Range v3 and the Future</h2>
<p>Range v3 forms the basis for a proposal to add ranges to the standard library (<a href="www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html">N4128</a>), and will also be the basis for a Technical Specification on Ranges. Its design direction has already passed an initial review by the standardization committee. What that means is that you may see your compiler vendor shipping a library like Range v3 at some point in the future. That's the hope, anyway.</p>
<p>Enjoy!</p>
<h1><a class="anchor" id="range-views"></a>
Range Views</h1>
<hr/>
<p> The big advantage of ranges over iterators is their <em>composability</em>. They permit a functional style of programming where data is manipulated by passing it through a series of combinators. In addition, the combinators can be <em>lazy</em>, only doing work when the answer is requested, and <em>purely functional</em>, without mutating the original data. This makes it easier to reason about your code, especially when writing concurrent programs.</p>
<p>Below is a list of the lazy range combinators, or <em>views</em>, that Range v3 provides, and a blurb about how each is intended to be used.</p>
<dl>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1adjacent__remove__if__fn.html"><code>view::adjacent_remove_if</code></a> </dt>
<dd>For each pair of adjacent elements in a source range, evaluate the specified binary predicate. If the predicate evaluates to false, the first element of the pair is included in the result range; otherwise, it is skipped. The first element in the source range is always included. (For instance, <code>adjacent_remove_if</code> with <code>std::equal_to</code> filters out all the non-unique elements.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1all__fn.html"><code>view::all</code></a> </dt>
<dd>Return a range containing all the elements in the source. Useful for converting containers to ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1bounded__fn.html"><code>view::bounded</code></a> </dt>
<dd>Convert the source range to a <em>bounded</em> range, where the type of the <code>end</code> is the same as the <code>begin</code>. Useful for iterating over a range with C++'s range-based <code>for</code> loop. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1chunk__fn.html"><code>view::chunk</code></a> </dt>
<dd>Given a source range and an integer <em>N</em>, produce a range of contiguous ranges where each inner range has <em>N</em> contiguous elements. The final range may have fewer than <em>N</em> elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1concat__fn.html"><code>view::concat</code></a> </dt>
<dd>Given <em>N</em> source ranges, produce a result range that is the concatenation of all of them. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1const__fn.html"><code>view::const_</code></a> </dt>
<dd>Present a <code>const</code> view of a source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1counted__fn.html"><code>view::counted</code></a> </dt>
<dd>Given an iterator <code>it</code> and a count <code>n</code>, create a range that starts at <code>it</code> and includes the next <code>n</code> elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1delimit__fn.html"><code>view::delimit</code></a> </dt>
<dd>Given a source range and a value, return a new range that ends either at the end of the source or at the first occurrence of the value, whichever comes first. Alternatively, <code>view::delimit</code> can be called with an iterator and a value, in which case it returns a range that starts at the specified position and ends at the first occurrence of the value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__fn.html"><code>view::drop</code></a> </dt>
<dd>Remove the first <em>N</em> elements from the front of a source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__while__fn.html"><code>view::drop_while</code></a> </dt>
<dd>Remove elements from the front of a range that satisfy a unary predicate. </dd>
<dt><a class="el" href="group__list.html#gaefc353c52b2ae6521cce4af15ffabdf1"><code>view::empty</code></a> </dt>
<dd>Create an empty range with a given value type. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1generate__fn.html"><code>view::generate</code></a> </dt>
<dd>Given a nullary function, return an infinite range whose elements are generated with the function. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1generate__n__fn.html"><code>view::generate_n</code></a> </dt>
<dd>Given a nullary function and a count, return a range that generates the requested number of elements by calling the function. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1group__by__fn.html"><code>view::group_by</code></a> </dt>
<dd>Given a source range and a binary predicate, return a range of ranges where each range contains contiguous elements from the source range such that the following condition holds: for each element in the range apart from the first, when that element and the first element are passed to the binary predicate, the result is true. In essence, <code>view::group_by</code> <em>groups</em> contiguous elements together with a binary predicate. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1indirect__fn.html"><code>view::indirect</code></a> </dt>
<dd>Given a source range of readable values (e.g. pointers or iterators), return a new view that is the result of dereferencing each. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1intersperse__fn.html"><code>view::intersperse</code></a> </dt>
<dd>Given a source range and a value, return a new range where the value is inserted between contiguous elements from the source. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1ints__fn.html"><code>view::ints</code></a> </dt>
<dd>Generate a range of monotonically increasing <code>int</code>s. When used without arguments, it generates the quasi-infinite range [0,1,2,3...]. It can also be called with a lower bound, or with a lower and upper bound (exclusive). </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1iota__fn.html"><code>view::iota</code></a> </dt>
<dd>A generalization of <code>view::ints</code> that generates a sequence of monotonically increasing values of any incrementable type. When specified with a single argument, the result is an infinite range beginning at the specified value. With two arguments, the values are assumed to denote a half-open range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1join__fn.html"><code>view::join</code></a> </dt>
<dd>Given a range of ranges, join them into a flattened sequence of elements. Optionally, you can specify a value or a range to be inserted between each source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1keys__fn.html"><code>view::keys</code></a> </dt>
<dd>Given a range of <code>pair</code>s (like a <code>std::map</code>), return a new range consisting of just the first element of the <code>pair</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1move__fn.html"><code>view::move</code></a> </dt>
<dd>Given a source range, return a new range where each element has been has been cast to an rvalue reference. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1partial__sum__fn.html"><code>view::partial_sum</code></a> </dt>
<dd>Given a range and a binary function, return a new range where the <em>N</em><sup>th</sup> element is the result of applying the function to the <em>N</em><sup>th</sup> element from the source range and the (N-1)th element from the result range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1remove__if__fn.html"><code>view::remove_if</code></a> </dt>
<dd>Given a source range and a unary predicate, filter out those elements that do not satisfy the predicate. (For users of Boost.Range, this is like the <code>filter</code> adaptor with the predicate negated.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1repeat__fn.html"><code>view::repeat</code></a> </dt>
<dd>Given a value, create a range that is that value repeated infinitely. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1repeat__n__fn.html"><code>view::repeat_n</code></a> </dt>
<dd>Given a value and a count, create a range that is that value repeated <em>count</em> number of times. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1replace__fn.html"><code>view::replace</code></a> </dt>
<dd>Given a source range, a source value and a target value, create a new range where all elements equal to the source value are replaced with the target value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1replace__if__fn.html"><code>view::replace_if</code></a> </dt>
<dd>Given a source range, a unary predicate and a target value, create a new range where all elements that satisfy the predicate are replaced with the target value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1reverse__fn.html"><code>view::reverse</code></a> </dt>
<dd>Create a new range that traverses the source range in reverse order. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1single__fn.html"><code>view::single</code></a> </dt>
<dd>Given a value, create a range with exactly one element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1slice__fn.html"><code>view::slice</code></a> </dt>
<dd>Give a source range a lower bound (inclusive) and an upper bound (exclusive), create a new range that begins and ends at the specified offsets. Both the begin and the end can be integers relative to the front, or relative to the end with "`end-2`" syntax. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1split__fn.html"><code>view::split</code></a> </dt>
<dd>Given a source range and a delimiter specifier, split the source range into a range of ranges using the delimiter specifier to find the boundaries. The delimiter specifier can be a value, a subrange, or a function. The function should accept current/end iterators into the source range and return <code>make_pair(true, length)</code> if the current position is a boundary; otherwise, <code>make_pair(false, 0)</code>. The delimiter character(s) are excluded from the resulting range of ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1stride__fn.html"><code>view::stride</code></a> </dt>
<dd>Given a source range and an integral stride value, return a range consisting of every <em>N</em><sup>th</sup> element, starting with the first. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1tail__fn.html"><code>view::tail</code></a> </dt>
<dd>Given a source range, return a new range without the first element. The range must have at least one element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__fn.html"><code>view::take</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of the first <em>count</em> elements from the source range, or the complete range if it has fewer elements. (The result of <code>view::take</code> is not a <code>SizedRange</code>.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__exactly__fn.html"><code>view::take_exactly</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of the first <em>count</em> elements from the source range. The source range must have at least that many elements. (The result of <code>view::take_exactly</code> is a <code>SizedRange</code>.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__while__fn.html"><code>view::take_while</code></a> </dt>
<dd>Given a source range and a unary predicate, return a new range consisting of the elements from the front that satisfy the predicate. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1tokenize__fn.html"><code>view::tokenize</code></a> </dt>
<dd>Given a source range and optionally a submatch specifier and a <code>std::regex_constants::match_flag_type</code>, return a <code>std::regex_token_iterator</code> to step through the regex submatches of the source range. The submatch specifier may be either a plain <code>int</code>, a <code>std::vector&lt;int&gt;</code>, or a <code>std::initializer_list&lt;int&gt;</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1transform__fn.html"><code>view::transform</code></a> </dt>
<dd>Given a source range and a unary function, return a new range where each result element is the result of applying the unary function to a source element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1unbounded__fn.html"><code>view::unbounded</code></a> </dt>
<dd>Given an iterator, return an infinite range that begins at that position. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1unique__fn.html"><code>view::unique</code></a> </dt>
<dd>Given a range, return a new range where all consecutive elements that compare equal save the first have been filtered out. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1values__fn.html"><code>view::values</code></a> </dt>
<dd>Given a range of <code>pair</code>s (like a <code>std::map</code>), return a new range consisting of just the second element of the <code>pair</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1zip__fn.html"><code>view::zip</code></a> </dt>
<dd>Given <em>N</em> ranges, return a new range where <em>M</em><sup>th</sup> element is the result of calling <code>make_tuple</code> on the <em>M</em><sup>th</sup> elements of all <em>N</em> ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1zip__with__fn.html"><code>view::zip_with</code></a> </dt>
<dd>Given <em>N</em> ranges and a <em>N</em>-ary function, return a new range where <em>M</em><sup>th</sup> element is the result of calling the function on the <em>M</em><sup>th</sup> elements of all <em>N</em> ranges. </dd>
</dl>
<h1><a class="anchor" id="tutorial-examples"></a>
Examples</h1>
<hr/>
<p>Below is a full example of a calendar program that, given a year, prints a formatted calendar to the console with 3 months per line. It demonstrates all the different parts of the Range-v3 library, including range view, action, and algorithms; as well as how to build custom ranges with <code>range_adaptor</code> and <code>range_facade</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Range v3 library</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Copyright Eric Niebler 2013-2015</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//  Use, modification and distribution is subject to the</span></div>
<div class="line"><span class="comment">//  Boost Software License, Version 1.0. (See accompanying</span></div>
<div class="line"><span class="comment">//  file LICENSE_1_0.txt or copy at</span></div>
<div class="line"><span class="comment">//  http://www.boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Project home: https://github.com/ericniebler/range-v3</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Usage:</span></div>
<div class="line"><span class="comment">//     calendar 2015</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Output:</span></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">        January              February                March</span></div>
<div class="line"><span class="comment">              1  2  3   1  2  3  4  5  6  7   1  2  3  4  5  6  7</span></div>
<div class="line"><span class="comment">  4  5  6  7  8  9 10   8  9 10 11 12 13 14   8  9 10 11 12 13 14</span></div>
<div class="line"><span class="comment"> 11 12 13 14 15 16 17  15 16 17 18 19 20 21  15 16 17 18 19 20 21</span></div>
<div class="line"><span class="comment"> 18 19 20 21 22 23 24  22 23 24 25 26 27 28  22 23 24 25 26 27 28</span></div>
<div class="line"><span class="comment"> 25 26 27 28 29 30 31                        29 30 31</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">         April                  May                  June</span></div>
<div class="line"><span class="comment">           1  2  3  4                  1  2      1  2  3  4  5  6</span></div>
<div class="line"><span class="comment">  5  6  7  8  9 10 11   3  4  5  6  7  8  9   7  8  9 10 11 12 13</span></div>
<div class="line"><span class="comment"> 12 13 14 15 16 17 18  10 11 12 13 14 15 16  14 15 16 17 18 19 20</span></div>
<div class="line"><span class="comment"> 19 20 21 22 23 24 25  17 18 19 20 21 22 23  21 22 23 24 25 26 27</span></div>
<div class="line"><span class="comment"> 26 27 28 29 30        24 25 26 27 28 29 30  28 29 30</span></div>
<div class="line"><span class="comment">                       31</span></div>
<div class="line"><span class="comment">         July                 August               September</span></div>
<div class="line"><span class="comment">           1  2  3  4                     1         1  2  3  4  5</span></div>
<div class="line"><span class="comment">  5  6  7  8  9 10 11   2  3  4  5  6  7  8   6  7  8  9 10 11 12</span></div>
<div class="line"><span class="comment"> 12 13 14 15 16 17 18   9 10 11 12 13 14 15  13 14 15 16 17 18 19</span></div>
<div class="line"><span class="comment"> 19 20 21 22 23 24 25  16 17 18 19 20 21 22  20 21 22 23 24 25 26</span></div>
<div class="line"><span class="comment"> 26 27 28 29 30 31     23 24 25 26 27 28 29  27 28 29 30</span></div>
<div class="line"><span class="comment">                       30 31</span></div>
<div class="line"><span class="comment">        October              November              December</span></div>
<div class="line"><span class="comment">              1  2  3   1  2  3  4  5  6  7         1  2  3  4  5</span></div>
<div class="line"><span class="comment">  4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12</span></div>
<div class="line"><span class="comment"> 11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19</span></div>
<div class="line"><span class="comment"> 18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26</span></div>
<div class="line"><span class="comment"> 25 26 27 28 29 30 31  29 30                 27 28 29 30 31</span></div>
<div class="line"><span class="comment">// */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Credits:</span></div>
<div class="line"><span class="comment">//   Thanks to H. S. Teoh for the article that served as the</span></div>
<div class="line"><span class="comment">//     inspiration for this example:</span></div>
<div class="line"><span class="comment">//     &lt;http://wiki.dlang.org/Component_programming_with_ranges&gt;</span></div>
<div class="line"><span class="comment">//   Thanks to github&#39;s Arzar for bringing date::week_number</span></div>
<div class="line"><span class="comment">//     to my attention.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/format.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/program_options.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_8hpp.html">range/v3/core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="view_2iota_8hpp.html">range/v3/view/iota.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="group__by_8hpp.html">range/v3/view/group_by.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="view_2transform_8hpp.html">range/v3/view/transform.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concat_8hpp.html">range/v3/view/concat.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="single_8hpp.html">range/v3/view/single.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="repeat__n_8hpp.html">range/v3/view/repeat_n.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="view_2take_8hpp.html">range/v3/view/take.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="view_2join_8hpp.html">range/v3/view/join.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="view_2all_8hpp.html">range/v3/view/all.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="action_2join_8hpp.html">range/v3/action/join.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_2copy_8hpp.html">range/v3/algorithm/copy.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_2for__each_8hpp.html">range/v3/algorithm/for_each.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mismatch_8hpp.html">range/v3/algorithm/mismatch.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>po = boost::program_options;</div>
<div class="line"><span class="keyword">namespace </span>greg = boost::gregorian;</div>
<div class="line"><span class="keyword">using</span> date = greg::date;</div>
<div class="line"><span class="keyword">using</span> day = greg::date_duration;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>gregorian {</div>
<div class="line">    date &amp;operator++(date &amp;d) { <span class="keywordflow">return</span> d = d + day(1); }</div>
<div class="line">    date operator++(date &amp;d, <span class="keywordtype">int</span>) { <span class="keywordflow">return</span> ++d - day(1); }</div>
<div class="line">}}</div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceranges.html">ranges</a> {</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>difference_type&lt;date&gt; {</div>
<div class="line">        <span class="keyword">using</span> type = date::duration_type::duration_rep::int_type;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line">CONCEPT_ASSERT(Incrementable&lt;date&gt;());</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> dates(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> start, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> stop) {</div>
<div class="line">    <span class="keywordflow">return</span> view::iota(date{start,greg::Jan,1},</div>
<div class="line">                      date{stop,greg::Jan,1});</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> dates_from(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> year) {</div>
<div class="line">    <span class="keywordflow">return</span> view::iota(date{year,greg::Jan,1});</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> by_month() {</div>
<div class="line">    <span class="keywordflow">return</span> view::group_by([](date a, date b) {</div>
<div class="line">        <span class="keywordflow">return</span> a.month() == b.month();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> by_week() {</div>
<div class="line">    <span class="keywordflow">return</span> view::group_by([](date a, date b) {</div>
<div class="line">        <span class="comment">// ++a because week_numer is Mon-Sun and we want Sun-Sat</span></div>
<div class="line">        <span class="keywordflow">return</span> (++a).week_number() == (++b).week_number();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::string format_day(date d) {</div>
<div class="line">    <span class="keywordflow">return</span> boost::str(boost::format(<span class="stringliteral">&quot;%|3|&quot;</span>) % d.day());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;Range&lt;date&gt;&gt;: month grouped by weeks.</span></div>
<div class="line"><span class="comment">// Out: Range&lt;std::string&gt;: month with formatted weeks.</span></div>
<div class="line"><span class="keyword">auto</span> format_weeks() {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>([](<span class="comment">/*Range&lt;date&gt;*/</span> <span class="keyword">auto</span> week) {</div>
<div class="line">        <span class="keywordflow">return</span> boost::str(boost::format(<span class="stringliteral">&quot;%1%%2%%|22t|&quot;</span>)</div>
<div class="line">            % std::string((<span class="keywordtype">int</span>)<a class="code" href="group__list.html#ga76ee33daea50a50b8231d77a41f2d4f2">front</a>(week).day_of_week() * 3, <span class="charliteral">&#39; &#39;</span>)</div>
<div class="line">            % (week | <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>(format_day) | <a class="code" href="group__transformation.html#ga2c4e5cc96ecaecd24f6b2205ea12c652">action::join</a>));</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Return a formatted string with the title of the month</span></div>
<div class="line"><span class="comment">// corresponding to a date.</span></div>
<div class="line">std::string month_title(date d) {</div>
<div class="line">    <span class="keywordflow">return</span> boost::str(boost::format(<span class="stringliteral">&quot;%|=22|&quot;</span>)</div>
<div class="line">        % d.month().as_long_string());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;Range&lt;date&gt;&gt;: year of months of days</span></div>
<div class="line"><span class="comment">// Out: Range&lt;Range&lt;std::string&gt;&gt;: year of months of formatted wks</span></div>
<div class="line"><span class="keyword">auto</span> layout_months() {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>([](<span class="comment">/*Range&lt;date&gt;*/</span> <span class="keyword">auto</span> month) {</div>
<div class="line">        <span class="keywordtype">int</span> week_count = distance(month | by_week());</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__transformation.html#gaf7be841db4ea7d88c3b00f3f2be03199">view::concat</a>(</div>
<div class="line">            view::single(month_title(<a class="code" href="group__list.html#ga76ee33daea50a50b8231d77a41f2d4f2">front</a>(month))),</div>
<div class="line">            month | by_week() | format_weeks(),</div>
<div class="line">            <a class="code" href="group__list.html#gaf343c443b2f37a0e4392c859254d3973">view::repeat_n</a>(std::string(22,<span class="charliteral">&#39; &#39;</span>),6-week_count));</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;T&gt;</span></div>
<div class="line"><span class="comment">// Out: Range&lt;Range&lt;T&gt;&gt;, where each inner range has $n$ elements.</span></div>
<div class="line"><span class="comment">//                       The last range may have fewer.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng&gt;</div>
<div class="line"><span class="keyword">class </span>chunk_view : <span class="keyword">public</span> range_adaptor&lt;chunk_view&lt;Rng&gt;, Rng&gt; {</div>
<div class="line">    CONCEPT_ASSERT(ForwardRange&lt;Rng&gt;());</div>
<div class="line">    <a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a> n_;</div>
<div class="line">    <span class="keyword">friend</span> range_access;</div>
<div class="line">    <span class="keyword">class </span>adaptor;</div>
<div class="line">    adaptor begin_adaptor() {</div>
<div class="line">        <span class="keywordflow">return</span> adaptor{n_, ranges::end(this-&gt;base())};</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    chunk_view() = <span class="keywordflow">default</span>;</div>
<div class="line">    chunk_view(Rng rng, <a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a> n)</div>
<div class="line">      : range_adaptor_t&lt;chunk_view&gt;(<a class="code" href="namespacestd.html">std</a>::move(rng)), n_(n)</div>
<div class="line">    {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng&gt;</div>
<div class="line"><span class="keyword">class </span>chunk_view&lt;Rng&gt;::adaptor : <span class="keyword">public</span> adaptor_base {</div>
<div class="line">    <a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a> n_;</div>
<div class="line">    range_sentinel_t&lt;Rng&gt; end_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    adaptor() = <span class="keywordflow">default</span>;</div>
<div class="line">    adaptor(<a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a> n, range_sentinel_t&lt;Rng&gt; end)</div>
<div class="line">      : n_(n), end_(end)</div>
<div class="line">    {}</div>
<div class="line">    <span class="keyword">auto</span> current(range_iterator_t&lt;Rng&gt; it)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> view::take(make_range(std::move(it), end_), n_);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> next(range_iterator_t&lt;Rng&gt; &amp;it) {</div>
<div class="line">        ranges::advance(it, n_, end_);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> prev() = <span class="keyword">delete</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;T&gt;</span></div>
<div class="line"><span class="comment">// Out: Range&lt;Range&lt;T&gt;&gt;, where each inner range has $n$ elements.</span></div>
<div class="line"><span class="comment">//                       The last range may have fewer.</span></div>
<div class="line"><span class="keyword">auto</span> chunk(<a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a> n) {</div>
<div class="line">    <span class="keywordflow">return</span> make_pipeable([=](<span class="keyword">auto</span>&amp;&amp; rng) {</div>
<div class="line">        <span class="keyword">using</span> Rng = decltype(rng);</div>
<div class="line">        <span class="keywordflow">return</span> chunk_view&lt;view::all_t&lt;Rng&gt;&gt;{</div>
<div class="line">            view::all(std::forward&lt;Rng&gt;(rng)), n};</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Flattens a range of ranges by iterating the inner</span></div>
<div class="line"><span class="comment">// ranges in round-robin fashion.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rngs&gt;</div>
<div class="line"><span class="keyword">class </span>interleave_view : <span class="keyword">public</span> range_facade&lt;interleave_view&lt;Rngs&gt;&gt; {</div>
<div class="line">    <span class="keyword">friend</span> range_access;</div>
<div class="line">    std::vector&lt;range_value_t&lt;Rngs&gt;&gt; rngs_;</div>
<div class="line">    <span class="keyword">struct </span>cursor;</div>
<div class="line">    cursor begin_cursor() {</div>
<div class="line">        <span class="keywordflow">return</span> {0, &amp;rngs_, <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>(rngs_, ranges::begin)};</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    interleave_view() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">explicit</span> interleave_view(Rngs rngs)</div>
<div class="line">      : rngs_(<a class="code" href="namespacestd.html">std</a>::move(rngs))</div>
<div class="line">    {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rngs&gt;</div>
<div class="line"><span class="keyword">struct </span>interleave_view&lt;Rngs&gt;::cursor  {</div>
<div class="line">    <a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a> n_;</div>
<div class="line">    std::vector&lt;range_value_t&lt;Rngs&gt;&gt; *rngs_;</div>
<div class="line">    std::vector&lt;range_iterator_t&lt;range_value_t&lt;Rngs&gt;&gt;&gt; its_;</div>
<div class="line">    decltype(<span class="keyword">auto</span>) current()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> *its_[n_];</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> next() {</div>
<div class="line">        <span class="keywordflow">if</span>(0 == ((++n_) %= its_.size()))</div>
<div class="line">            <a class="code" href="group__runtime.html#ga4d1b825778809ff9c5f20c84d7f06a0f">for_each</a>(its_, [](<span class="keyword">auto</span>&amp; it){ ++it; });</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> done()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> n_ == 0 &amp;&amp; its_.end() != mismatch(its_,</div>
<div class="line">            <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>(*rngs_, ranges::end), std::not_equal_to&lt;&gt;()).first;</div>
<div class="line">    }</div>
<div class="line">    CONCEPT_REQUIRES(ForwardRange&lt;range_value_t&lt;Rngs&gt;&gt;())</div>
<div class="line">    bool equal(cursor const&amp; that)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> n_ == that.n_ &amp;&amp; its_ == that.its_;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;Range&lt;T&gt;&gt;</span></div>
<div class="line"><span class="comment">// Out: Range&lt;T&gt;, flattened by walking the ranges</span></div>
<div class="line"><span class="comment">//                round-robin fashion.</span></div>
<div class="line"><span class="keyword">auto</span> interleave() {</div>
<div class="line">    <span class="keywordflow">return</span> make_pipeable([](<span class="keyword">auto</span>&amp;&amp; rngs) {</div>
<div class="line">        <span class="keyword">using</span> Rngs = decltype(rngs);</div>
<div class="line">        <span class="keywordflow">return</span> interleave_view&lt;view::all_t&lt;Rngs&gt;&gt;(</div>
<div class="line">            view::all(std::forward&lt;Rngs&gt;(rngs)));</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;Range&lt;T&gt;&gt;</span></div>
<div class="line"><span class="comment">// Out: Range&lt;Range&lt;T&gt;&gt;, transposing the rows and columns.</span></div>
<div class="line"><span class="keyword">auto</span> transpose() {</div>
<div class="line">    <span class="keywordflow">return</span> make_pipeable([](<span class="keyword">auto</span>&amp;&amp; rngs) {</div>
<div class="line">        <span class="keyword">using</span> Rngs = decltype(rngs);</div>
<div class="line">        CONCEPT_ASSERT(ForwardRange&lt;Rngs&gt;());</div>
<div class="line">        <span class="keywordflow">return</span> std::forward&lt;Rngs&gt;(rngs)</div>
<div class="line">            | interleave()</div>
<div class="line">            | chunk(distance(rngs));</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;Range&lt;Range&lt;string&gt;&gt;&gt;</span></div>
<div class="line"><span class="comment">// Out: Range&lt;Range&lt;Range&lt;string&gt;&gt;&gt;, transposing months.</span></div>
<div class="line"><span class="keyword">auto</span> transpose_months() {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>([](<span class="comment">/*Range&lt;Range&lt;string&gt;&gt;*/</span> <span class="keyword">auto</span> rng) {</div>
<div class="line">        <span class="keywordflow">return</span> rng | transpose();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;Range&lt;string&gt;&gt;</span></div>
<div class="line"><span class="comment">// Out: Range&lt;string&gt;, joining the strings of the inner ranges</span></div>
<div class="line"><span class="keyword">auto</span> join_months() {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__transformation.html#gae8666f91063c050fe79f817c03b81b3f">view::transform</a>([](<span class="comment">/*Range&lt;string&gt;*/</span> <span class="keyword">auto</span> rng) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__transformation.html#ga2c4e5cc96ecaecd24f6b2205ea12c652">action::join</a>(rng);</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In:  Range&lt;date&gt;</span></div>
<div class="line"><span class="comment">// Out: Range&lt;string&gt;, lines of formatted output</span></div>
<div class="line"><span class="keyword">auto</span> format_calendar(<a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a> months_per_line) {</div>
<div class="line">    <span class="keywordflow">return</span> make_pipeable([=](<span class="keyword">auto</span> &amp;&amp; rng) {</div>
<div class="line">        <span class="keyword">using</span> Rng = decltype(rng);</div>
<div class="line">        <span class="keywordflow">return</span> std::forward&lt;Rng&gt;(rng)</div>
<div class="line">            <span class="comment">// Group the dates by month:</span></div>
<div class="line">          | by_month()</div>
<div class="line">            <span class="comment">// Format the month into a range of strings:</span></div>
<div class="line">          | layout_months()</div>
<div class="line">            <span class="comment">// Group the months that belong side-by-side:</span></div>
<div class="line">          | chunk(months_per_line)</div>
<div class="line">            <span class="comment">// Transpose the rows and columns of the size-by-side months:</span></div>
<div class="line">          | transpose_months()</div>
<div class="line">            <span class="comment">// Ungroup the side-by-side months:</span></div>
<div class="line">          | <a class="code" href="group__transformation.html#ga2c4e5cc96ecaecd24f6b2205ea12c652">view::join</a></div>
<div class="line">            <span class="comment">// Join the strings of the transposed months:</span></div>
<div class="line">          | join_months();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) <span class="keyword">try</span> {</div>
<div class="line">    <span class="comment">// Declare the supported options.</span></div>
<div class="line">    po::options_description desc(<span class="stringliteral">&quot;Allowed options&quot;</span>);</div>
<div class="line">    desc.add_options()</div>
<div class="line">        (<span class="stringliteral">&quot;help&quot;</span>, <span class="stringliteral">&quot;produce help message&quot;</span>)</div>
<div class="line">        (<span class="stringliteral">&quot;start&quot;</span>, po::value&lt;unsigned short&gt;(), <span class="stringliteral">&quot;Year to start&quot;</span>)</div>
<div class="line">        (<span class="stringliteral">&quot;stop&quot;</span>, po::value&lt;std::string&gt;(), <span class="stringliteral">&quot;Year to stop&quot;</span>)</div>
<div class="line">        (<span class="stringliteral">&quot;per-line&quot;</span>, po::value&lt;std::size_t&gt;()-&gt;default_value(3u), <span class="stringliteral">&quot;Nbr of months per line&quot;</span>)</div>
<div class="line">    ;</div>
<div class="line"></div>
<div class="line">    po::positional_options_description p;</div>
<div class="line">    p.add(<span class="stringliteral">&quot;start&quot;</span>, 1).add(<span class="stringliteral">&quot;stop&quot;</span>, 1);</div>
<div class="line"></div>
<div class="line">    po::variables_map vm;</div>
<div class="line">    po::store(po::command_line_parser(argc, argv).</div>
<div class="line">              options(desc).positional(p).run(), vm);</div>
<div class="line">    po::notify(vm);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(vm.count(<span class="stringliteral">&quot;help&quot;</span>) || 1 != vm.count(<span class="stringliteral">&quot;start&quot;</span>)) {</div>
<div class="line">        std::cerr &lt;&lt; desc &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> start = vm[<span class="stringliteral">&quot;start&quot;</span>].as&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>&gt;();</div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> stop = 0 == vm.count(<span class="stringliteral">&quot;stop&quot;</span>) ?</div>
<div class="line">        (<span class="keywordtype">unsigned</span> short)(start + 1) :</div>
<div class="line">        vm[<span class="stringliteral">&quot;stop&quot;</span>].as&lt;std::string&gt;() == <span class="stringliteral">&quot;never&quot;</span> ?</div>
<div class="line">            (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)-1 :</div>
<div class="line">            boost::lexical_cast&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>&gt;(vm[<span class="stringliteral">&quot;stop&quot;</span>].as&lt;std::string&gt;());</div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> months_per_line = vm[<span class="stringliteral">&quot;per-line&quot;</span>].as&lt;<a class="code" href="group__integral.html#ga878079c524e6d2f43e2617b25a03d514">std::size_t</a>&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(stop != (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)-1 &amp;&amp; stop &lt;= start) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: The stop year must be larger than the start&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)-1 != stop) {</div>
<div class="line">        copy(dates(start, stop) | format_calendar(months_per_line),</div>
<div class="line">            ostream_iterator&lt;&gt;(std::cout, <span class="stringliteral">&quot;\n&quot;</span>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        copy(dates_from(start) | format_calendar(months_per_line),</div>
<div class="line">            ostream_iterator&lt;&gt;(std::cout, <span class="stringliteral">&quot;\n&quot;</span>));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(std::exception &amp;e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: Unhandled exception\n&quot;</span>;</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;  what(): &quot;</span> &lt;&lt; e.what();</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
