<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../stylesheets/stylesheet.css" type="text/css" />
</head>
<body>
<!-- HEADER -->
<div id="header_wrap" class="outer">
  <header class="inner">
    <a id="forkme_banner" href="https://github.com/ericniebler/range-v3">View on GitHub</a>
    <h1 id="project_title">Range v3</h1>
    <h2 id="project_tagline"></h2>
  </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
<div id="TOC">
<ul>
<li><a href="#quick-start"><span class="toc-section-number">1</span> Quick Start</a><ul>
<li><a href="#why-use-ranges"><span class="toc-section-number">1.1</span> Why Use Ranges?</a><ul>
<li><a href="#convenience"><span class="toc-section-number">1.1.1</span> Convenience</a></li>
<li><a href="#composability"><span class="toc-section-number">1.1.2</span> Composability</a><ul>
<li><a href="#range-views"><span class="toc-section-number">1.1.2.1</span> Range views</a></li>
<li><a href="#container-algorithms"><span class="toc-section-number">1.1.2.2</span> Container Algorithms</a></li>
</ul></li>
</ul></li>
<li><a href="#create-custom-ranges"><span class="toc-section-number">1.2</span> Create Custom Ranges</a></li>
<li><a href="#adapting-ranges"><span class="toc-section-number">1.3</span> Adapting Ranges</a></li>
<li><a href="#constrain-functions-with-concepts"><span class="toc-section-number">1.4</span> Constrain Functions with Concepts</a></li>
<li><a href="#range-v3-and-the-future"><span class="toc-section-number">1.5</span> Range v3 and the Future</a></li>
</ul></li>
</ul>
</div>
<h1 id="quick-start"><span class="header-section-number">1</span> Quick Start</h1>
<p>Range v3 is a generic library that augments the existing standard library with facilities for working with <em>ranges</em>. A range can be loosely thought of a pair of iterators, although they need not be implemented that way. Bundling begin/end iterators into a single object brings several benefits.</p>
<h2 id="why-use-ranges"><span class="header-section-number">1.1</span> Why Use Ranges?</h2>
<h3 id="convenience"><span class="header-section-number">1.1.1</span> Convenience</h3>
<p>Itâ€™s more convenient to pass a single range object to an algorithm than separate begin/end iterators. Compare:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; v{<span class="co">/*...*/</span>};
std::sort( v.begin(), v.end() );</code></pre>
<p>with</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; v{<span class="co">/*...*/</span>};
ranges::sort( v );</code></pre>
<p>Range v3 contains a full implementation of all the standard algorithms with range-based overloads for convenience.</p>
<h3 id="composability"><span class="header-section-number">1.1.2</span> Composability</h3>
<p>Having a single range object permits <em>pipelines</em> of operations. In a pipeline, a range is lazily adapted or eagerly mutated in some way, with the result immediately available for further adaptation or mutation. Lazy adaption is handled by <em>range views</em>, and eager mutation is handled by <em>container algorithms</em>.</p>
<h4 id="range-views"><span class="header-section-number">1.1.2.1</span> Range views</h4>
<p>A range view is a lightweight wrapper that presents a view of an underlying sequence of elements in some custom way without mutating or copying it. Views are cheap to create and copy, and have non-owning reference semantics. Below are some examples:</p>
<ol>
<li><p>Filter a container using a predicate and transform it.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; vi{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>};
<span class="kw">using</span> <span class="kw">namespace</span> ranges;
<span class="kw">auto</span> rng = vi | view::filter([](<span class="dt">int</span> i){<span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span>;})
              | view::transform([](<span class="dt">int</span> i){<span class="kw">return</span> std::to_string(i);});
<span class="co">// rng == {&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;};</span></code></pre></li>
<li><p>Generate an infinite list of integers starting at 1, square them, take the first 10, and sum them:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> ranges;
<span class="dt">int</span> sum = accumulate(view::ints(<span class="dv">1</span>)
                   | view::transform([](<span class="dt">int</span> i){<span class="kw">return</span> i*i;})
                   | view::take(<span class="dv">10</span>), <span class="dv">0</span>);</code></pre></li>
<li><p>Generate a sequence on the fly with a range comprehension and initialize a vector with it:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> ranges;
std::vector&lt;<span class="dt">int</span>&gt; vi =
    view::for_each(view::ints(<span class="dv">1</span>,<span class="dv">10</span>), [](<span class="dt">int</span> i){
        <span class="kw">return</span> yield_from(view::repeat(i,i));
    });
<span class="co">// vi == {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...}</span></code></pre></li>
</ol>
<h4 id="container-algorithms"><span class="header-section-number">1.1.2.2</span> Container Algorithms</h4>
<p>When you want to mutate a container in-place, or forward it through a chain of mutating operations, you can use container algorithms. The following examples should make it clear.</p>
<ol>
<li><p>Read data into a vector, sort it, and make it unique.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">extern</span> std::vector&lt;<span class="dt">int</span>&gt; read_data();
<span class="kw">using</span> <span class="kw">namespace</span> ranges;
std::vector&lt;<span class="dt">int</span>&gt; vi = read_data() | cont::sort | cont::unique;</code></pre></li>
<li><p>Do the same to a <code>vector</code> that already contains some data:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vi = std::move(vi) | cont::sort | cont::unique;</code></pre></li>
<li><p>Mutate the container in-place:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vi |= cont::sort | cont::unique;</code></pre></li>
<li><p>Same as above, but with function-call syntax instead of pipe syntax:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">cont::unique(cont::sort(vi));</code></pre></li>
</ol>
<h2 id="create-custom-ranges"><span class="header-section-number">1.2</span> Create Custom Ranges</h2>
<p>Range v3 provides a utility for easily creating your own range types, called <code>range_facade</code>. The Code below uses <code>range_facade</code> to create a range that traverses a null-terminated string:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;range/v3/all.hpp&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> ranges;

<span class="co">// A range that iterates over all the characters in a</span>
<span class="co">// null-terminated string.</span>
<span class="kw">class</span> c_string_range
  : <span class="kw">public</span> range_facade&lt;c_string_range&gt;
{
    <span class="kw">friend</span> range_access;
    <span class="dt">char</span> <span class="dt">const</span> * sz_;
    <span class="dt">char</span> <span class="dt">const</span> &amp; current() <span class="dt">const</span> { <span class="kw">return</span> *sz_; }
    <span class="dt">bool</span> done() <span class="dt">const</span> { <span class="kw">return</span> *sz_ == <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>; }
    <span class="dt">void</span> next() { ++sz_; }
<span class="kw">public</span>:
    c_string_range() = <span class="kw">default</span>;
    <span class="kw">explicit</span> c_string_range(<span class="dt">char</span> <span class="dt">const</span> *sz) : sz_(sz)
    {
        assert(sz != <span class="kw">nullptr</span>);
    }
};</code></pre>
<p>The <code>range_facade</code> class generates an iterator and begin/end member functions from the minimal interface provided by <code>c_string_range</code>. This is an example of a very simple range for which it is not necessary to separate the range itself from the thing that iterates the range. Future examples will show examples of more sophisticated ranges.</p>
<p>With <code>c_string_range</code>, you can now use algorithms to operate on null-terminated strings, as below:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    c_string_range r(<span class="st">&quot;hello world&quot;</span>);
    <span class="co">// Iterate over all the characters and print them out</span>
    ranges::for_each(r, [](<span class="dt">char</span> ch){
        std::cout &lt;&lt; ch &lt;&lt; <span class="st">&#39; &#39;</span>;
    });
    <span class="co">// prints: h e l l o   w o r l d</span>
}</code></pre>
<h2 id="adapting-ranges"><span class="header-section-number">1.3</span> Adapting Ranges</h2>
<p>Often, a new range type is most easily expressed by adapting an existing range type. Thatâ€™s the case for many of the range views provided by the Range v3 library; for example, the <code>view::filter</code> and <code>view::transform</code> views. These are rich types with many moving parts, but thanks to a helper class called <code>range_adaptor</code>, they arenâ€™t hard to write.</p>
<p>Below in roughly 2 dozen lines of code is the <code>transform</code> view, which takes one range and transforms all the elements with a unary function.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// A class that adapts an existing range with a function</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Rng, <span class="kw">class</span> Fun&gt;
<span class="kw">class</span> transform_view : <span class="kw">public</span> range_adaptor&lt;transform_view&lt;Rng, Fun&gt;, Rng&gt;
{
    <span class="kw">friend</span> range_access;
    semiregular_t&lt;Fun&gt; fun_; <span class="co">// Make Fun model SemiRegular if it doesn&#39;t</span>
    <span class="kw">class</span> adaptor : <span class="kw">public</span> adaptor_base
    {
        semiregular_t&lt;Fun&gt; fun_;
    <span class="kw">public</span>:
        adaptor() = <span class="kw">default</span>;
        adaptor(semiregular_t&lt;Fun&gt; <span class="dt">const</span> &amp;fun) : fun_(fun) {}
        <span class="co">// Here is where we apply Fun to the elements:</span>
        <span class="kw">auto</span> current(range_iterator_t&lt;Rng&gt; it) <span class="dt">const</span> -&gt; <span class="kw">decltype</span>(fun_(*it))
        {
            <span class="kw">return</span> fun_(*it);
        }
    };
    adaptor begin_adaptor() <span class="dt">const</span> { <span class="kw">return</span> {fun_}; }
    adaptor end_adaptor() <span class="dt">const</span> { <span class="kw">return</span> {fun_}; }
<span class="kw">public</span>:
    transform_view() = <span class="kw">default</span>;
    transform_view(Rng &amp;&amp; rng, Fun fun)
      : range_adaptor_t&lt;transform_view&gt;{std::forward&lt;Rng&gt;(rng)}
      , fun_(std::move(fun))
    {}
};

<span class="kw">template</span>&lt;<span class="kw">class</span> Rng, <span class="kw">class</span> Fun&gt;
transform_view&lt;Rng, Fun&gt; transform(Rng &amp;&amp; rng, Fun fun)
{
    <span class="kw">return</span> {std::forward&lt;Rng&gt;(rng), std::move(fun)};
}</code></pre>
<p>Range transformation is achieved by defining a nested <code>adaptor</code> class that handles the transformation, and then defining <code>begin_adaptor</code> and <code>end_adaptor</code> members that return adaptors for the begin iterator and the end sentinel, respectively. The <code>adaptor</code> class has a <code>current</code> member that performs the transformation. It is passed an iterator to the current element. Other members are available for customization: <code>equal</code>, <code>next</code>, <code>prev</code>, <code>advance</code>, and <code>distance_to</code>; but the transform adaptor takes the defaults defined in <code>adaptor_base</code>.</p>
<p>With <code>transform_view</code>, we can print out the first 20 squares:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> squares = ::transform(view::ints(<span class="dv">1</span>), [](<span class="dt">int</span> i){<span class="kw">return</span> i*i;});
    <span class="kw">for</span>(<span class="dt">int</span> i : squares | view::take(<span class="dv">20</span>))
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&#39; &#39;</span>;
    std::cout &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
    <span class="co">// prints 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400</span>
}</code></pre>
<p>The <code>transform_view</code> defined above is an InputRange when its wrapping an InputRange, a ForwardRange when its wrapping a ForwardRange, etc. That happens because of smart defaults defined in the <code>adaptor_base</code> class. That frees you from having to deal with a host of niggly detail when implementing iterators.</p>
<p><em>(Note: the above <code>transform_view</code> always stores a copy of the function in the sentinel. That is only necessary if the underlying rangeâ€™s sentinel type models BidirectionalIterator. Thatâ€™s a finer point that you shouldnâ€™t worry about right now.)</em></p>
<h2 id="constrain-functions-with-concepts"><span class="header-section-number">1.4</span> Constrain Functions with Concepts</h2>
<p>The Range v3 library makes heavy use of concepts to constrain functions, control overloading, and check type constraints at compile-time. It achieves this with the help of a Concepts Lite emulation layer that works on any standard-conforming C++11 compiler. The library provides many useful concepts, both for the core language and for iterators and ranges. You can use the concepts framework to constrain your own code.</p>
<p>For instance, if you would like to write a function that takes an iterator/sentinel pair, you can write it like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> Iter, <span class="kw">class</span> Sent, <span class="kw">class</span> Comp = <span class="co">/*...some_default..*/</span>,
    CONCEPT_REQUIRES_(IteratorRange&lt;Iter, Sent&gt;())&gt;
<span class="dt">void</span> my_algorithm(Iter first, Sent last, Comp comp = Comp{})
{
    <span class="co">// ...</span>
}</code></pre>
<p>You can then add an overload that take an Iterable:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> Rng, <span class="kw">class</span> Comp = <span class="co">/*...some_default..*/</span>,
    CONCEPT_REQUIRES_(Iterable&lt;Rng&gt;())&gt;
<span class="dt">void</span> my_algorithm(Rng &amp;&amp; rng, Comp comp = Comp{})
{
    <span class="kw">return</span> my_algorithm(ranges::begin(rng), ranges::end(rng));
}</code></pre>
<p>With the type constraits expressed with the <code>CONCEPTS_REQUIRES_</code> macro, these two overloads are guaranteed to not be ambiguous.</p>
<h2 id="range-v3-and-the-future"><span class="header-section-number">1.5</span> Range v3 and the Future</h2>
<p>Range v3 forms the basis for a proposal to add ranges to the standard library<br />(<a href="www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html">N4128</a>), and will also be the basis for a Technical Specification on Ranges. Its design direction has already passed an initial review by the standardization committee. What that means is that you may see your compiler vendor shipping a library like Range v3 at some point in the future. Thatâ€™s the hope, anyway.</p>
<p>Enjoy!</p>
<div class="references">

</div>
  </section>
</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
  </footer>
</div>
</body>
</html>
