<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
    <tr>
        <td width="172" align="left" valign="top">Document number:</td>
        <td width="435"><span style="background-color: #FFFF00">D4128</span>=yy-nnnn</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Date:</td>
        <td width="435">2014-07-26</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Project:</td>
        <td width="435">Programming Language C++, Library Working Group</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Reply-to:</td>
        <td width="435">Eric Niebler &lt;<a href="mailto:eniebler@boost.org">eniebler@boost.org</a>&gt;</td>
    </tr>
</table>

Ranges for the Standard Library, Revision 1
===========================================

I. Table of Contents
--------------------

TODO

II. Introduction
----------------

This paper presents a proposal to add support for ranges to the C++ standard library. A "range" is an object that refers to a sequence of elements, conceptually similiar to a pair of iterators. The benefits of ranges have been long understood and documented elsewhere[ref?], but the details of ranges and range-based algorithms have proved tricky to precisely nail down. This proposal aims to make specific recommendations based on the author(s) experience of designing, implementing, supporting and using several popular range libraries.

This paper assumes the availability of Concepts Lite; however, everything suggested here has been implemented in C++11, where Concepts Lite has been simulated with the help of generalized SFINAE for expressions.

III. Motivation and Scope
-------------------------

The primary motivation for ranges is simple enough: to give users a simpler syntax for calling algorithms. Rather than this:

    std::vector<int> v { /*...*/ };
    std::sort( v.begin(), v.end() );

Ranges would give us a pithier syntax:

    std::sort( v );

Allowing algorithms to take a single range object instead of separate begin and end iterators brings other benefits besides convenience. In particular:

  * It eliminates the possiblility of mismatched iterators.
  * It also opens the door to *range adaptors* which lazily transform or filter their underlying sequence in interesting ways.

Range adaptors are far more compelling than iterator adaptors due to the fact that only a single object, the range object, needs to be adapted; hence, adaptors can be easily chained to create lazy computational pipelines, as in the code below which sums the first 10 squares:

    int total = accumulate(view::iota(1) |
                           view::transform([](int x){return x*x;}) |
                           view::take(10), 0);

### Design Space Exploration

The design space for ranges is surprisingly large. At one end of the spectrum lies [Boost.Range] [2] and [Adobe's ASL] [3] in which ranges are a thin abstraction on top of iterators, which remain the primitives that glue together data structures and algorithms. At the other end of the spectrum we find the [D Standard Library's std.range module] [4], in which ranges and operations on them are the primitives themselves.

This section explores the range design space by describing options among which any library designer must choose.

#### Are Range Operations Primitive?

Iterators are a lower-level abstraction than ranges. Arrays, strings, vectors, maps, sets ... collections of things are closer to most domains than the position-in-sequence abstration that iterators represent. It would be a boon to do away with iterators entirely if range primitives were found to be a complete replacement for them.

The most comprehensive effort to replace iterators with ranges to date was undertaken by Andrei Alexandrescu when designing the D Standard Library. The result is, in the opinion of this author, a success.

This paper does not deeply explore the ranges-as-primitives approach taken by the D Standard Library. The reasons for this are as follows:

 * Such an approach would abandon a large investment in the iterator abstraction and create a schism within the standard library and in the community at large between range-based and iterator-based algorithms, which couldn't share code.
 * Although the concept of "sequence" undoubtably comes up more frequently in most domains than "position in sequence," completely banishing the concept of position leads to some awkward constructions. For example, trying to express an algorithm like `find` without the notion of "position" leads to the slightly contrived (but admitedly sometimes useful) convention of returning a range. But which range to return? Indeed, the D Standard Library has as many `find` algorithms since there are many answers to this question. (TODO reference)
 * Iterators as primitives are provably more powerful than ranges. 

##### Position-Based Ranges

An alternate design is found in [James Touton's range library] [5], where ranges -- together with a new Position concept -- are the primitives. A Position, as its name suggests, represents a position in a range. Unlike an iterator, a position cannot be used to access the element at that position without the range into which it refers. In that sense, a position is a generalization of an index into an array, in the same sense that an iterator is a generalization of a pointer. TODO discuss pros and cons of this design.

#### Can Ranges Own Elements?

This question may be rephrased, "Are containers ranges, or are they merely *convertible* to ranges?" This seemingly essoteric question has practical consequences when your are considering copying a range. Is that guaranteed to be O(1) in the number of elements or potentially O(N)?

#### Are Ranges EqualityComparable, and With What Semantics?

Two vectors compare equal iff they have the same size and each element compares equal. Are ranges also equality comparable, and with the same semantics? This question is related to the question of whether ranges can own their elements. Whether they can or can't, the answer has implications for the behavior of `operator==` if ranges are to model the Regular concept. In the Regular concept, the semantics of copy, assignment, and equality comparison are related to each other by axioms.

In any case, this much is true: in a world where both `std::vector<int>` and `std::pair<int*,int*>` can model Range, then the Range concept cannot refine EqualityComparable because the semantics of `operator==` differ for the two models. Since I believe EqualityComparable-ness (and Regular-ness) are desirable properties for Range, something has to give.

#### Do Range Adaptors Aggregate Ranges/Containers By Value?

This question is related to the "Can Ranges Own Elements?" question and revolves around the issue of what should happen when an rvalue container or range is adapted. If ranges are allowed to own their elements, it makes sense that the range adaptor should take ownership of the container by moving it into itself.

#### Can Iterators Outlive Their Ranges?

TODO

#### Can End Iterators Have a Different Type Than Begin Iterators?

TODO

IV. Impact on the Standard
--------------------------

This paper imagines changes to the following parts of the standard:

- New library-wide concepts related to ranges.
- New iterator algorithms for efficiently dealing with the new abstractions.
- Changes existing algorithms to constrain the templates
- Adds additional overloads of existing algorithms that accept ranges instead of pairs of iterators.
- Changes to the containers to allow containers to be constructed and assigned from ranges, and to allow range-based insert operations.
- Adds a new library section for range adaptors, which are views of existing data that have been transformed or filtered and that compose with other views.
- General utilities for the construction of custom range adaptors.(???)
- A minor change to the specification of the range-based `for` to make it more efficient and general.

V. Design Decisions
-------------------

### Design Assumptions

The author has to make several assumptions when arriving at his design decisions, many of which may prove to be faulty or unjustifiable. They are:

- That concepts will be baked into some version of the standard library.
- That in that process, to avoid a repeat of the C++0x Concepts experience and to preserve strict backwards compatibility while delivering a *sane* set of concepts with which the standard library is constrained, it will be decided to deliver the new standard library along side the old one, in a separate versioned namespace.
- That this opportunity will occasion the correction of small oversights in the library.

In other words, the author has given himself the freedom to make changes to the standard library that are not strictly source-code compatible with old code; that the integration of concepts will cause breakage *anyway*, so we might as well seize the opportunity to "do it right". If that turns out not to be the case, fallbacks will be discussed. (Most of the small breaking changes implied by the following design decisions have natural, conservative fallbacks. Those fallbacks are less satisfactory in that they either leave long-standing issues unaddressed or introduce new inconsistencies, but it's nothing we couldn't live with.)

### Design Decisions

*TODO Explain the whys behind these choices.*

The following is true of Ranges and Iterables:

- The type of the end iterator (hereafter refered to as a "sentinel") can differ from that of the begin iterator.
- When an Iterable is destroyed, any iterators generated from that range are invalidated.
- Iterables do not logically own their elements. They refer to elements stored elsewhere (or are generated on demand).
- Iterables are Regular types, so copies are independent. An iterator from an Iterable `A` that was copied from `B`
  is not invalidated when `B` is destroyed.
- If an un-cv-qualified type `T` models Iterable, then the type `T const` need not. This permits ranges that maintain
  mutable internal state; e.g., an `istream` range. *However...*
- Given an un-cv-qualified type `T`, for both `T` and `T const` to model Iterable, then
  `range_iterator_t<T>` and `range_iterator_t<T const>` must be the same type.

The following is true of algorithms:

- Algorithms are changed to reflect the fact that the sentinel may have a different type than the begin iterator.
- Algorithms, in addition to the old versions that take begin/end iterator/sentinel arguments, now have versions
  that take Iterable arguments in place of begin/end pairs.
- Algorithm versions that take Iterables are semantically identical to the identically-named versions that takes
  iterator/sentinel pairs. The two flavors have the same return types. Both evaluate eagerly.
- Algorithms that necessarily process their entire input sequence return the iterator position at the end in
  addition to whatever else they return. The purpose is to return potentially useful information that is computed
  as a side-effect of the normal execution of the algorithm; for example, the position of a C-style string's null
  terminator. Exceptions to this design guideline are made when one of the following is true:
    * The algorithm might in some cases not consume the entire input sequence. (The point of this exception is
      to avoid forcing the algorithm to compute something that is not necessary for successful completion. For
      example, `find`.)
    * When the sole purpose of the algorithm is specifically to compute a single value; hence, changing
      the return type will necessarily break code using the C++11 version. Examples include `is_sorted` and
      `accumulate`.
- "Three-legged" iterator-based algorithms now have 4 versions:
    * The old three-legged iterator version (that has traditionally merely assumed the sequence denoted by the third
      iterator is long enough),
    * A four-legged version that uses the sentinel of the second sequence as an additional termination condition,
    * A version that takes an Iterable and an Iterator (which dispatches to the three-legged iterator-based version),
      and
    * A version that takes two Iterables (which dispatches to the four-legged iterator-based version).
- Purely as an implementation consideration, the three-legged algorithms must be able to distinguish a native array
  from an iterator; e.g. when the user calls the algorithm with an array as the second input sequence (where either
  an Iterable or an iterator is allowed to appear). Naively coded, this would be ambiguous due to the decay of arrays
  to pointers. In this case, it should dispatch to the version that takes two Iterables, not the version that takes
  an Iterable and an iterator.
- Algorithms that do not mutate their input sequence must also work when `initializer_list`s are used in place of
  Iterables.
- If an algorithm returns an iterator into an Iterable argument, the Iterable must be an lvalue. This is to avoid
  returning an iterator that is immediately made invalid. Conversely, if no iterator into an Iterable argument is
  returned, then the Iterable should be taken by "universal reference".
- Algorithms that take callables should work with any kind of INVOKE-able entity (see [func.require]); for example,
  pointers to data members are valid unary INVOKE-able objects.
- Wherever appropriate, algorithms should optionally take INVOKE-able *projections* that are applied to each element
  in the input sequence(s). This, in effect, allows users to trivially transform each input sequence for the sake
  of that single algorithm invocation. The reason for projections is described in
  [Sean Parent's "C++ Seasoning" talk](https://github.com/sean-parent/sean-parent.github.com/wiki/presentations/2013-09-11-cpp-seasoning/cpp-seasoning.pdf) on slide 38.
- Algorithms that take two input sequences should (optionally) take two projections.
- For algorithms that optionally accept functions/predicates (e.g. `transform`, `sort`), projection arguments
  positionally follow functions/predicates. There are no algorithm overloads that allow the user to specify the
  projection without also specifying a predicate, even if the default would suffice. This is to reduce the
  number of overloads and also to avoid any potential for ambiguity.

#### On Sentinels versus End Iterators

Arguably the most radical idea in this proposal is to allow the type of the end iterator to differ from the type of the begin iterator. Loosening the constraints of the end iterator brings several benefits:

* More sequence types can trivially qualify as "ranges" if the position of the end is not required to be known *a priori*; for example, a null-terminated character sequence, or a sequence whose end is determined by a predicate, or range specified by an iterator and a count.
* It eliminates the need to mock-up dummy end iterators, like `std::istream_iterator` and `std::regex_iterator`, the logic of which is tricky to get right.
* It improves code generation for some types of ranges. With the use of dummy end iterators, information which is known at compile-time -- namely, that an iterator represents the end -- must be encoded into runtime information in the iterator itself. When the type of the end iterator is allowed to differ, its "end-ness" can be encoded in the type system, which gives the compiler the information it needs to eliminate branches from the core loops of many algorithms. See Appendix 1 for an example of how sentinels can positively effect code generation.

When considering this choice for the range concept, it's helpful to think about how it would effect the algorithms. Consider `std::for_each`, which currently has this signature:

    template<class InputIterator, class Function>
    Function for_each(InputIterator first, InputIterator last, Function f)
    {
        for(; first != last; ++first)
            f(*first);
        return f;
    }

With sentinels, `for_each` might look like this:

    template<class InputIterator, class Sentinel, class Function>
        requires( /* ... constraints ... */ )
    Function for_each(InputIterator first, Sentinel last, Function f)
    {
        for(; first != last; ++first)
            f(*first);
        return f;
    }

None of the code in the algorithm had to change. No calling code would have to change either; this is a strictly backwards-compatible change. You might think that this opens a new category of programming errors where developers inadvertantly pass mismatched iterator/sentinel pairs. However, this algorithm signature would be constrained with concept checks that would ensure that `InputIterator` and `Sentinel` satisfied the cross-type EqualityComparable concept (refs N3351). See Appendix 2 for further discussion about Iterator/Sentinel cross-type EqualityComparability constraint.

To see the benefit of this design, imagine a sentinel type `null_sentinel`:

    // For determining whether an iterator refers to a null value:
    struct null_sentinel
    {
        template<Iterator I>
        friend bool operator==(I i, null_sentinel) { return 0 == *i; }
        template<Iterator I>
        friend bool operator==(null_sentinel, I i) { return 0 == *i; }
        template<Iterator I>
        friend bool operator!=(I i, null_sentinel) { return 0 != *i; }
        template<Iterator I>
        friend bool operator!=(null_sentinel, I i) { return 0 != *i; }
    };

Now we can use `std::for_each` on null-terminated strings without needing to know the length of the string:

    std::for_each(argv[1], null_sentinel(), f);

Of course, all the algorithms would have overloads that also accept range arguments, so this can be further simplified to:

    std::for_each(null_terminated(argv[1]), f);

where `null_terminated(InputIterator)` returns a range `r` such that the `std::end(r)` is a `null_sentinel`.

**Further Benefits of Sentinels**

One excuse sometimes given for not using the standard algorithm is that they don't give the users a way to break out of them early. The use of sentinels makes that possible. Consider a sentinel constructed from both an end iterator and a predicate. Such a sentinel would compare equal to an iterator *either* when the iterator equals the end iterator *or* when the predicate evaluates to true. Using such a sentinel has the effect of terminating an algorithm early. For instance:

    // Process work items in a queue, allowing for a user interrupt
    std::queue<Work> q;
    std::function<void(Work const &)> user_interrupt = /*...*/;
    std::for_each( q | until(user_interrupt), f );

In the above, `until` is a range modifier that adds an extra termination constraint, and `|` is the operation for generating range views by applying a modifier to a range.

**Further Implications of Sentinels**

Notice that in the due course of evaluating `std::for_each` with `null_sentinel`, the position of the null terminator is found. This is potentially useful information that can easily be returned to the user. It is, in fact, a far more interesting and useful result that the `Function` that `for_each` currently returns. So a better signature for `for_each` should look like this:

    // Returns an InputIterator i such that (i == last) is true:
    template<class InputIterator, class Sentinel, class Function>
        requires( /* ... constraints ... */ )
    InputIterator for_each(InputIterator first, Sentinel last, Function f);

In similar fashion, most algorithm get new return types when they are generalized to support sentinels. This is a source-breaking change in many cases. In some cases, like `for_each`, the change is unlikely to be very disruptive. In other cases it may be more so. Simply accepting the breakage is one possibility, and the one that leads to the cleanest design, and the fewest gotchas in the future.

A fallback design is to only change the return type when the types of the iterator and the sentinel differ. This leads to a slightly more complicated interface that may confuse users. It also greatly complicates generic code, which would need metaprogramming logic just to use the result of calling some algorithms. For this reason, this possibilty is not explored here.

The committee may decide to deliver the new standard library in a separate namespace that users must opt into. In that case, no code is broken until the user explicitly ports their code. The user would have to accomodate the changed return types then. An automated upgrade tool similiar to clang modernize (TODO REF) can greatly help here.

#### On Projections

TODO

### Range Concepts

TODO

VI. Technical Specifications
----------------------------

This section intentionally left blank.

VII. Future Directions
----------------------

- Range extensions to things like regex. Make it work with null-terminated strings, e.g..
- Discuss the pros and cons of tying this work with work on a concept-ified standard library (aka Concepts Lite TS2).
- Discuss the pros and cons of making this (and the concept-ified standard library) *strictly* backwards compatible, versus delivering the new, conceptified and range-ified standard library in a separate, versioned namespace (and what such a solution should look like).

VII. Acknowledgements
---------------------

TODO Too many to list!

VIII. References
----------------

[2]: http://www.boost.org/libs/range "Boost.Range"
[3]: http://stlab.adobe.com/ "Adobe ASL"
[4]: http://dlang.org/phobos/std_range.html "D Phobos std.range"
[5]: https://github.com/Bekenn/range "Position-Based Ranges"

Appendix 1: Sentinels and Code Generation
-----------------------------------------

TODO

Appendix 2: Sentinels, Iterators, and the Cross-Type EqualityComparable Constraint
----------------------------------------------------------------------------------

TODO

